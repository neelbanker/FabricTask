const FabricClient = require('fabric-client');
const FabricCAClient = require('fabric-ca-client/lib/FabricCAClientImpl.js');
const Orderer = require('fabric-client/lib/Orderer.js');
const Peer = require('fabric-client/lib/Peer.js');
const User = require('fabric-client/lib/User.js');
const uuidv4 = require('uuid/v4');
const winston = require('winston-color');

/**
 * A connection to a Fabric network
 *
 * TODO:
 *
 * Events
 * Endorsement Policies
 * Install/Instantiate
 *
 * Invoking assumes you want an OK repsonse from everyone, add an option to specify who exactly you
 * want a response from. send off when all of those, if not specified assume (any/all).
 *
 * Query, in much the same way you should specify who you want
 */
class Stitch {
  /**
   * Takes the connection and enrollment profiles and parses them into the SDK's representation of
   * a fabric network in memory as well as loading the credentials of the specified user and setting them as the
   * current user context.
   * @param {*} connectionProfile IBM Cloud Connection Profile detailing network/chaincode topology and endpoints
   * @param {*} enrollmentProfile Specifies username/secret and where to store the credentials
   */
  async configure(connectionProfile, enrollmentProfile) {
    this.connectionProfile = connectionProfile;
    this.enrollmentProfile = enrollmentProfile;
    this.client = new FabricClient();
    this.caClients = [];

    // Set up a store on disk for Certificates
    let store = await FabricClient.newDefaultKeyValueStore({
      path: this.enrollmentProfile.storePath
    });
    this.client.setStateStore(store);

    // Set up a store on disk for Keys
    const cryptoSuite = FabricClient.newCryptoSuite();
    cryptoSuite.setCryptoKeyStore(
      FabricClient.newCryptoKeyStore({
        path: this.enrollmentProfile.cryptoStorePath
      })
    );
    this.client.setCryptoSuite(cryptoSuite);

    // Set up CAs
    for (let caId of Object.keys(this.connectionProfile.certificateAuthorities)) {
      // Get CA data from profile
      const ca = this.connectionProfile.certificateAuthorities[caId];

      // TLS options if there are any
      const tlsOptions = {
        trustedRoots: ['tlsCACerts' in ca ? ca.tlsCACerts.pem : null],
        verify: false
      };

      const newCaClient = new FabricCAClient(ca.url, tlsOptions, ca.caName, cryptoSuite);
      this.caClients.push(newCaClient);
    }
    
    // Load the user credentials from disk or enroll at the CA (then persist to disk)
    this.user = await this.loadUser(enrollmentProfile.id, enrollmentProfile.mspId);
    await this.client.setUserContext(this.user);

    // Create all the network objects
    this.parseNetwork();
  }

  /**
   * Takes the information in the enrollment profile and checks if the user is already on disk (at the
   * specified path). If so it loads from disk, otherwise it enrolls the user with the CA, stores the credentials
   * on disk at the path and sets the user as the current user context.
   */
  async loadUser(id, mspId) {
    let user = await this.client.getUserContext(id, true);

    // SDK first checks locally on disk for user credentials
    if (user && user.isEnrolled()) {
      // There might be two users with this ID but of different MSPs
      if (user._mspId !== mspId) {
        throw `Found ID '${id}' on disk but it's MSP (${user._mspId}) does not match the one in specified in the enrollment profile (${mspId}),
         please clear the K/V Store`;
      } else {
        console.log(`Found User '${id}' on disk and loaded credentials successfully`);
        return user;
      }

      // If the credentials aren't on disk, enroll the user from the CA
    }
  }

  /**
   * Registers a new user with the CA service, the current user context MUST be an
   * account with the privileges to create new users to run this without error.
   * @param {*} username
   */
  async registerUser(id, secret, affiliation) {
    const request = {
      enrollmentID: id,
      enrollmentSecret: secret,
      maxEnrollments: 0,
      affiliation
    };

    // Who is executing this action?
    const registrar = await this.client.getUserContext('admin');

    // Make a new user
    return this.caClients[0].register(request, registrar);
  }

  /**
   * Takes the Connection Profile generated by IBM Cloud and parses it into
   * the Channel/Peer/Orderer objects the SDK uses to represent the network in memory.
   */
  parseNetwork() {
    this.channels = {};

    // Assemble the channels. Peers and orderers are looked up separately for each channel as peer membership
    // of each channel is not necessarily consistent.
    for (let channelID of Object.keys(this.connectionProfile.channels)) {
      // Create the channel
      const channelProfile = this.connectionProfile.channels[channelID];
      const channel = this.client.newChannel(channelID);

      // Add orderers
      for (let ordererID of Object.keys(this.connectionProfile.orderers)) {
        const ordererProfile = this.connectionProfile.orderers[ordererID];
        channel.addOrderer(new Orderer(ordererProfile.url, { 'pem': ordererProfile.tlsCACerts.pem, 'ssl-target-name-override': ordererProfile.sslTargetNameOverride }));
      }
      
      // Add peers
      for (let peerID of Object.keys(this.connectionProfile.peers)) {
        const peerProfile = this.connectionProfile.peers[peerID];
        channel.addPeer(new Peer(peerProfile.url, { 'pem': peerProfile.tlsCACerts.pem, 'ssl-target-name-override': peerProfile.sslTargetNameOverride }));
      }

      this.channels[channelID] = channel;
      winston.info(`Set up channel ${channelID}`);
    }

    winston.info('Successfully set up channel structures');
  }

  /**
   * Invoke chaincode
   * @param {*} channelId
   * @param {*} chaincodeId
   * @param {*} fcn
   * @param {*} args
   * @return {response}
   */
  async invoke(channelId, chaincodeId, fcn, args, transientMap) {
    const channel = this.channels[channelId];
    let request;

    if (transientMap) {
      request = {
        chaincodeId,
        fcn,
        args,
        transientMap,
        txId: this.client.newTransactionID()
      };
    } else {
      request = {
        chaincodeId,
        fcn,
        args,
        txId: this.client.newTransactionID()
      };
    }

    // Send Proposal and check it
    winston.info(`Sending transaction proposal to invoke '${chaincodeId}' on '${channelId}', calling '${fcn}' with ${args.length} args`);

    let results = await channel
      .sendTransactionProposal(request)
      .then(res => {
        if (res[0] instanceof Error) {
          return Promise.reject(res[0]);
        }
        return Promise.resolve(res);
      })
      .catch(err => {
        return Promise.reject({
          statusCode: err.statusCode,
          message: err.details
        });
      });

    console.log(results[1].payload.toString('utf8'));

    request = this.checkProposalResponses(results);

    // If successful send the actual transaction and check it
    winston.info(`Proposal approved, invoking ${chaincodeId} on ${channelId}, calling ${fcn} with ${args}`);
    let response = await channel
      .sendTransaction(request)
      .then(res => {
        if (res[0] instanceof Error) {
          return Promise.reject(res[0]);
        }
        return Promise.resolve(res);
      })
      .catch(err => {
        return Promise.reject({
          statusCode: err.statusCode,
          message: err.details
        });
      });

    return response;
  }

  /**
   * Query chaincode
   * @param {*} channelId
   * @param {*} chaincodeId
   * @param {*} fcn
   * @param {*} args
   * @return {response}
   */
  async query(channelId, chaincodeId, fcn, args) {
    const channel = this.channels[channelId];

    let request = {
      chaincodeId,
      fcn,
      args,
      txId: this.client.newTransactionID(),
      targets: [channel.getPeers()[0]]
    };

    return await channel
      .queryByChaincode(request)
      .then(res => {
        if (res[0] instanceof Error) {
          return Promise.reject(res[0]);
        }
        return Promise.resolve(res);
      })
      .catch(err => {
        return Promise.reject({
          statusCode: err.statusCode,
          message: err.details
        });
      });
  }

  /**
   * Checks that the responses to an invocation proposal are all approvals
   * @param {*} responses
   */
  checkProposalResponses(responses) {
    const proposalResponses = responses[0];

    // Go through the responses and check that, first, we have some and second they are all 200 OKs
    if (proposalResponses) {
      for (let proposalResponse of proposalResponses) {
        if (!proposalResponse.response || proposalResponse.response.status !== 200) {
          throw proposalResponse;
        }
      }
    } else {
      throw 'No proposal responses';
    }

    // If we've got everything return the request object to submit the transaction to the orderers
    return {
      proposalResponses,
      proposal: responses[1],
      header: responses[2]
    };
  }

  /**
   * Generates a random UUID
   */
  generateUUID() {
    return uuidv4();
  }
}

module.exports = Stitch;
